# -*- coding: utf-8 -*-
"""TransferLearningModel.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1miRIfjRyph9vOqxsTS_fLKv6vfEdezHC
"""

from keras.layers import Reshape
from tensorflow.keras.optimizers import Adam
from keras.models import load_model, Model
from keras.layers import Dense
from keras.callbacks import EarlyStopping, ModelCheckpoint
import matplotlib.pyplot as plt

class TransferLearningModel:

    def __init__(self, base_model_path, target_regions, n_timesteps, n_features, n_outputs, strategy, epochs=250):
        self.base_model_path = base_model_path
        self.target_regions = target_regions
        self.n_timesteps = n_timesteps
        self.n_features = n_features
        self.n_outputs = n_outputs
        self.strategy = strategy
        self.epochs = epochs
        self.model = None
        self.history = None

        if self.strategy == 'S1':
            self.build_model_strategy_1()
        elif self.strategy == 'S2':
            self.build_model_strategy_2()
        elif self.strategy == 'S3':
            self.build_model_strategy_3()
        else:
            raise ValueError(f"Invalid strategy {self.strategy}. Choose from 'S1', 'S2', 'S3'.")

    def build_model_strategy_1(self):
        # Load base model and freeze all layers except last one
        self.model = load_model(self.base_model_path)
        for layer in self.model.layers[:-1]:
            layer.trainable = False

    def build_model_strategy_2(self):
        # Load base model and use it as weight initialization for TL model
        self.model = load_model(self.base_model_path)

    def build_model_strategy_3(self):
        # Load base model and freeze initial layers, add new output layer
        self.model = load_model(self.base_model_path)
        for layer in self.model.layers[:-1]:
            layer.trainable = False
        self.model.layers[-2].trainable = True
        self.model.pop()
        x = self.model.layers[-1].output
        x = Dense(self.n_outputs)(x)
        self.model = Model(inputs=self.model.input, outputs=x)

    def compile_model(self, learning_rate=0.001):
        optimizer = Adam(learning_rate=learning_rate)
        self.model.compile(optimizer=optimizer, loss='mse')
        self.model.summary()

    def fit_model(self, train_data, train_labels, val_data, val_labels, batch_size=128 ,patience=10, verbose=1,
                checkpoint_path=None):
        # Define early stopping and model checkpoint callbacks
        early_stopping = EarlyStopping(monitor='val_loss', patience=patience, verbose=verbose, mode='min', restore_best_weights=True)
        model_checkpoint = None
        if checkpoint_path is not None:
            model_checkpoint = ModelCheckpoint(checkpoint_path, monitor='val_loss', verbose=verbose, save_best_only=True, mode='min')

        # Fit the model
        if model_checkpoint is not None:
            self.history = self.model.fit(train_data, train_labels, validation_data=(val_data, val_labels), batch_size=batch_size, epochs=self.epochs,
                                        callbacks=[model_checkpoint,early_stopping], verbose=verbose)
        else:
            self.history = self.model.fit(train_data, train_labels, validation_data=(val_data, val_labels), batch_size=batch_size, epochs=self.epochs,
                                        callbacks=[early_stopping], verbose=verbose)

    def load_trained_model(self, path):
        self.model = load_model(path)

    def plot_loss_history(self):
        train_loss = self.history.history['loss']
        val_loss = self.history.history['val_loss']
        epochs = range(1, len(train_loss) + 1)
        plt.plot(epochs, train_loss, 'bo', label='Training loss')
        plt.plot(epochs, val_loss, 'b', label='Validation loss')
        plt.title('Training and validation loss')
        plt.xlabel('Epochs')
        plt.ylabel('Loss')
        plt.legend()
        plt.show()

    def save_trained(self,path):
        self.model.save(path)

    def predict(self, data):
        return self.model.predict(data)
